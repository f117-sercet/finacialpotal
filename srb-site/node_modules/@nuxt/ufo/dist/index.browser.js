(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Ufo = {}));
}(this, (function (exports) { 'use strict';

  function withoutTrailingSlash(input = "/") {
    return input.endsWith("/") ? input.slice(0, -1) : input;
  }
  function withTrailingSlash(input = "/") {
    return input.endsWith("/") ? input : input + "/";
  }
  function hasProtocol(inputStr) {
    return /\w+:\//.test(inputStr);
  }
  function parseURL(input = "/") {
    if (typeof input !== "string") {
      if (!input || !input.url) {
        throw new Error(`Invalid url: ${JSON.stringify(input)}`);
      }
      return input;
    }
    const _hasProtocol = hasProtocol(input);
    const url = new URL(input, _hasProtocol ? void 0 : "default:/");
    return {url, hasProtocol: _hasProtocol};
  }
  function joinPath(...path) {
    const last = path.pop();
    if (!last) {
      return "/";
    }
    return path.map(withoutTrailingSlash).join("") + last;
  }
  function normalizeURL(input, stripBase) {
    const {url, hasProtocol: hasProtocol2} = parseURL(input);
    return !stripBase && hasProtocol2 ? url.href : url.pathname + url.search + url.hash;
  }
  function joinURL(input0, ...input) {
    const path = input.map(parseURL);
    const baseURL = parseURL(input0);
    baseURL.url.pathname = joinPath(baseURL.url.pathname, ...path.map((p) => p.url.pathname));
    return normalizeURL(baseURL);
  }

  exports.hasProtocol = hasProtocol;
  exports.joinPath = joinPath;
  exports.joinURL = joinURL;
  exports.normalizeURL = normalizeURL;
  exports.parseURL = parseURL;
  exports.withTrailingSlash = withTrailingSlash;
  exports.withoutTrailingSlash = withoutTrailingSlash;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
